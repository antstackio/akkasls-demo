"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StartedGenericContainer = exports.GenericContainer = exports.GenericContainerBuilder = void 0;
const archiver_1 = __importDefault(require("archiver"));
const container_state_1 = require("./container-state");
const docker_client_instance_1 = require("./docker-client-instance");
const logger_1 = require("./logger");
const port_binder_1 = require("./port-binder");
const port_check_1 = require("./port-check");
const pull_policy_1 = require("./pull-policy");
const docker_image_name_1 = require("./docker-image-name");
const test_container_1 = require("./test-container");
const uuid_1 = require("./uuid");
const wait_strategy_1 = require("./wait-strategy");
const reaper_1 = require("./reaper");
const port_forwarder_1 = require("./port-forwarder");
const registry_auth_locator_1 = require("./registry-auth-locator");
class GenericContainerBuilder {
    constructor(context, dockerfileName, uuid = new uuid_1.RandomUuid()) {
        this.context = context;
        this.dockerfileName = dockerfileName;
        this.uuid = uuid;
        this.buildArgs = {};
    }
    withBuildArg(key, value) {
        this.buildArgs[key] = value;
        return this;
    }
    build() {
        return __awaiter(this, void 0, void 0, function* () {
            const dockerImageName = new docker_image_name_1.DockerImageName(undefined, this.uuid.nextUuid(), this.uuid.nextUuid());
            const dockerClient = yield docker_client_instance_1.DockerClientInstance.getInstance();
            yield dockerClient.buildImage(dockerImageName, this.context, this.dockerfileName, this.buildArgs);
            const container = new GenericContainer(dockerImageName.toString());
            if (!(yield container.isImageCached(dockerClient))) {
                throw new Error("Failed to build image");
            }
            return Promise.resolve(container);
        });
    }
}
exports.GenericContainerBuilder = GenericContainerBuilder;
class GenericContainer {
    constructor(image) {
        this.image = image;
        this.env = {};
        this.ports = [];
        this.cmd = [];
        this.bindMounts = [];
        this.tmpFs = {};
        this.startupTimeout = 60000;
        this.useDefaultLogDriver = false;
        this.privilegedMode = false;
        this.daemonMode = false;
        this.pullPolicy = new pull_policy_1.DefaultPullPolicy();
        this.extraHosts = [];
        this.dockerImageName = docker_image_name_1.DockerImageName.fromString(image);
    }
    static fromDockerfile(context, dockerfileName = "Dockerfile") {
        return new GenericContainerBuilder(context, dockerfileName);
    }
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            const dockerClient = yield docker_client_instance_1.DockerClientInstance.getInstance();
            if (this.pullPolicy.shouldPull() || !(yield this.isImageCached(dockerClient))) {
                const authConfig = this.dockerImageName.registry ? yield registry_auth_locator_1.getAuthConfig(this.dockerImageName.registry) : undefined;
                yield dockerClient.pull(this.dockerImageName, authConfig);
            }
            const boundPorts = yield new port_binder_1.PortBinder().bind(this.ports);
            if (!this.dockerImageName.isReaper()) {
                yield reaper_1.ReaperInstance.getInstance(dockerClient);
            }
            if (this.preCreate) {
                yield this.preCreate(dockerClient, boundPorts);
            }
            if (!this.dockerImageName.isHelperContainer() && port_forwarder_1.PortForwarderInstance.isRunning()) {
                const portForwarder = yield port_forwarder_1.PortForwarderInstance.getInstance(dockerClient);
                this.extraHosts.push({ host: "host.testcontainers.internal", ipAddress: portForwarder.getIpAddress() });
            }
            const container = yield dockerClient.create({
                dockerImageName: this.dockerImageName,
                env: this.env,
                cmd: this.cmd,
                bindMounts: this.bindMounts,
                tmpFs: this.tmpFs,
                boundPorts,
                name: this.name,
                networkMode: this.networkMode,
                healthCheck: this.healthCheck,
                useDefaultLogDriver: this.useDefaultLogDriver,
                privilegedMode: this.privilegedMode,
                autoRemove: this.daemonMode,
                extraHosts: this.extraHosts,
            });
            if (!this.dockerImageName.isHelperContainer() && port_forwarder_1.PortForwarderInstance.isRunning()) {
                const portForwarder = yield port_forwarder_1.PortForwarderInstance.getInstance(dockerClient);
                const portForwarderNetworkId = portForwarder.getNetworkId();
                const excludedNetworks = [portForwarderNetworkId, "none", "host"];
                if (!this.networkMode || !excludedNetworks.includes(this.networkMode)) {
                    yield dockerClient.connectToNetwork(container.getId(), portForwarderNetworkId);
                }
            }
            if (this.tarToCopy) {
                this.tarToCopy.finalize();
                yield container.putArchive(this.tarToCopy, "/");
            }
            logger_1.log.info(`Starting container ${this.dockerImageName} with ID: ${container.getId()}`);
            yield dockerClient.start(container);
            if (!this.daemonMode) {
                (yield container.logs())
                    .on("data", (data) => logger_1.containerLog.trace(`${container.getId()}: ${data}`))
                    .on("err", (data) => logger_1.containerLog.error(`${container.getId()}: ${data}`));
            }
            const inspectResult = yield container.inspect();
            const containerState = new container_state_1.ContainerState(inspectResult);
            yield this.waitForContainer(dockerClient, container, containerState, boundPorts);
            return new StartedGenericContainer(container, dockerClient.getHost(), inspectResult, boundPorts, inspectResult.name, dockerClient);
        });
    }
    withCmd(cmd) {
        this.cmd = cmd;
        return this;
    }
    withName(name) {
        this.name = name;
        return this;
    }
    withEnv(key, value) {
        this.env[key] = value;
        return this;
    }
    withTmpFs(tmpFs) {
        this.tmpFs = tmpFs;
        return this;
    }
    withNetworkMode(networkMode) {
        this.networkMode = networkMode;
        return this;
    }
    withExposedPorts(...ports) {
        this.ports = ports;
        return this;
    }
    withBindMount(source, target, bindMode = "rw") {
        this.bindMounts.push({ source, target, bindMode });
        return this;
    }
    withHealthCheck(healthCheck) {
        this.healthCheck = healthCheck;
        return this;
    }
    withStartupTimeout(startupTimeout) {
        this.startupTimeout = startupTimeout;
        return this;
    }
    withWaitStrategy(waitStrategy) {
        this.waitStrategy = waitStrategy;
        return this;
    }
    withDefaultLogDriver() {
        this.useDefaultLogDriver = true;
        return this;
    }
    withPrivilegedMode() {
        this.privilegedMode = true;
        return this;
    }
    withPullPolicy(pullPolicy) {
        this.pullPolicy = pullPolicy;
        return this;
    }
    withDaemonMode() {
        this.daemonMode = true;
        return this;
    }
    withCopyFileToContainer(sourcePath, containerPath) {
        this.getTarToCopy().file(sourcePath, { name: containerPath });
        return this;
    }
    withCopyContentToContainer(content, containerPath) {
        this.getTarToCopy().append(content, { name: containerPath });
        return this;
    }
    isImageCached(dockerClient) {
        return __awaiter(this, void 0, void 0, function* () {
            const dockerImageNames = yield dockerClient.fetchDockerImageNames();
            return dockerImageNames.some((dockerImageName) => dockerImageName.equals(this.dockerImageName));
        });
    }
    getTarToCopy() {
        if (!this.tarToCopy) {
            this.tarToCopy = archiver_1.default("tar");
        }
        return this.tarToCopy;
    }
    waitForContainer(dockerClient, container, containerState, boundPorts) {
        return __awaiter(this, void 0, void 0, function* () {
            logger_1.log.debug(`Waiting for container to be ready: ${container.getId()}`);
            const waitStrategy = this.getWaitStrategy(dockerClient, container);
            try {
                yield waitStrategy.withStartupTimeout(this.startupTimeout).waitUntilReady(container, containerState, boundPorts);
                logger_1.log.info("Container is ready");
            }
            catch (err) {
                logger_1.log.error(`Container failed to be ready: ${err}`);
                if (this.daemonMode) {
                    (yield container.logs())
                        .on("data", (data) => logger_1.containerLog.trace(`${container.getId()}: ${data}`))
                        .on("err", (data) => logger_1.containerLog.error(`${container.getId()}: ${data}`));
                }
                try {
                    yield container.stop({ timeout: 0 });
                    yield container.remove({ removeVolumes: true });
                }
                catch (stopErr) {
                    logger_1.log.error(`Failed to stop container after it failed to be ready: ${stopErr}`);
                }
                throw err;
            }
        });
    }
    getWaitStrategy(dockerClient, container) {
        if (this.waitStrategy) {
            return this.waitStrategy;
        }
        const hostPortCheck = new port_check_1.HostPortCheck(dockerClient.getHost());
        const internalPortCheck = new port_check_1.InternalPortCheck(container, dockerClient);
        return new wait_strategy_1.HostPortWaitStrategy(dockerClient, hostPortCheck, internalPortCheck);
    }
}
exports.GenericContainer = GenericContainer;
class StartedGenericContainer {
    constructor(container, host, inspectResult, boundPorts, name, dockerClient) {
        this.container = container;
        this.host = host;
        this.inspectResult = inspectResult;
        this.boundPorts = boundPorts;
        this.name = name;
        this.dockerClient = dockerClient;
    }
    stop(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.stopContainer(options);
        });
    }
    stopContainer(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            logger_1.log.info(`Stopping container with ID: ${this.container.getId()}`);
            const resolvedOptions = Object.assign(Object.assign({}, test_container_1.DEFAULT_STOP_OPTIONS), options);
            yield this.container.stop({ timeout: resolvedOptions.timeout });
            yield this.container.remove({ removeVolumes: resolvedOptions.removeVolumes });
            return new StoppedGenericContainer();
        });
    }
    getHost() {
        return this.host;
    }
    getMappedPort(port) {
        return this.boundPorts.getBinding(port);
    }
    getId() {
        return this.container.getId();
    }
    getName() {
        return this.name;
    }
    getNetworkNames() {
        return Object.keys(this.inspectResult.networkSettings);
    }
    getNetworkId(networkName) {
        return this.inspectResult.networkSettings[networkName].networkId;
    }
    getIpAddress(networkName) {
        return this.inspectResult.networkSettings[networkName].ipAddress;
    }
    exec(command) {
        return this.dockerClient.exec(this.container, command);
    }
    logs() {
        return this.container.logs();
    }
}
exports.StartedGenericContainer = StartedGenericContainer;
class StoppedGenericContainer {
}
