"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DockerodeClient = void 0;
const stream_to_array_1 = __importDefault(require("stream-to-array"));
const tar_fs_1 = __importDefault(require("tar-fs"));
const slash_1 = __importDefault(require("slash"));
const container_1 = require("./container");
const docker_ignore_1 = require("./docker-ignore");
const logger_1 = require("./logger");
const docker_image_name_1 = require("./docker-image-name");
const pull_stream_parser_1 = require("./pull-stream-parser");
class DockerodeClient {
    constructor(host, dockerode, sessionId) {
        this.host = host;
        this.dockerode = dockerode;
        this.sessionId = sessionId;
    }
    pull(dockerImageName, authConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            logger_1.log.info(`Pulling image: ${dockerImageName}`);
            const stream = yield this.dockerode.pull(dockerImageName.toString(), { authconfig: authConfig });
            yield new pull_stream_parser_1.PullStreamParser(dockerImageName, logger_1.log).consume(stream);
        });
    }
    create(options) {
        return __awaiter(this, void 0, void 0, function* () {
            logger_1.log.info(`Creating container for image: ${options.dockerImageName}`);
            const dockerodeContainer = yield this.dockerode.createContainer({
                name: options.name,
                Image: options.dockerImageName.toString(),
                Env: this.getEnv(options.env),
                ExposedPorts: this.getExposedPorts(options.boundPorts),
                Cmd: options.cmd,
                Labels: this.createLabels(options.dockerImageName),
                // @ts-ignore
                Healthcheck: this.getHealthCheck(options.healthCheck),
                HostConfig: {
                    ExtraHosts: this.getExtraHosts(options.extraHosts),
                    AutoRemove: options.autoRemove,
                    NetworkMode: options.networkMode,
                    PortBindings: this.getPortBindings(options.boundPorts),
                    Binds: this.getBindMounts(options.bindMounts),
                    Tmpfs: options.tmpFs,
                    LogConfig: this.getLogConfig(options.useDefaultLogDriver),
                    Privileged: options.privilegedMode,
                },
            });
            return new container_1.DockerodeContainer(dockerodeContainer);
        });
    }
    connectToNetwork(containerId, networkId) {
        return __awaiter(this, void 0, void 0, function* () {
            logger_1.log.debug(`Connecting container ${containerId} to network ${networkId}`);
            const network = this.dockerode.getNetwork(networkId);
            yield network.connect({ Container: containerId });
        });
    }
    createNetwork(options) {
        return __awaiter(this, void 0, void 0, function* () {
            logger_1.log.info(`Creating network ${options.name}`);
            const network = yield this.dockerode.createNetwork({
                Name: options.name,
                CheckDuplicate: options.checkDuplicate,
                Driver: options.driver,
                Internal: options.internal,
                Attachable: options.attachable,
                Ingress: options.ingress,
                EnableIPv6: options.enableIPv6,
                Options: options.options,
                Labels: Object.assign(Object.assign({}, options.labels), this.createLabels()),
            });
            return network.id;
        });
    }
    removeNetwork(id) {
        return __awaiter(this, void 0, void 0, function* () {
            logger_1.log.info(`Removing network ${id}`);
            const network = this.dockerode.getNetwork(id);
            const { message } = yield network.remove();
            if (message) {
                logger_1.log.warn(message);
            }
        });
    }
    start(container) {
        return container.start();
    }
    exec(container, command) {
        return __awaiter(this, void 0, void 0, function* () {
            const exec = yield container.exec({
                cmd: command,
                attachStdout: true,
                attachStderr: true,
            });
            const stream = (yield exec.start()).setEncoding("utf-8");
            return yield new Promise((resolve) => {
                let output = "";
                stream.on("data", (chunk) => (output += chunk));
                const interval = setInterval(() => __awaiter(this, void 0, void 0, function* () {
                    const { running, exitCode } = yield exec.inspect();
                    if (!running) {
                        clearInterval(interval);
                        stream.destroy();
                        resolve({ output, exitCode });
                    }
                }), 100);
            });
        });
    }
    buildImage(dockerImageName, context, dockerfileName, buildArgs) {
        return __awaiter(this, void 0, void 0, function* () {
            logger_1.log.info(`Building image '${dockerImageName.toString()}' with context '${context}'`);
            const dockerIgnoreFiles = yield docker_ignore_1.findDockerIgnoreFiles(context);
            const tarStream = tar_fs_1.default.pack(context, { ignore: (name) => dockerIgnoreFiles.has(slash_1.default(name)) });
            const stream = yield this.dockerode.buildImage(tarStream, {
                dockerfile: dockerfileName,
                buildargs: buildArgs,
                t: dockerImageName.toString(),
                labels: this.createLabels(dockerImageName),
            });
            yield stream_to_array_1.default(stream);
        });
    }
    fetchDockerImageNames() {
        return __awaiter(this, void 0, void 0, function* () {
            const images = yield this.dockerode.listImages();
            return images.reduce((dockerImageNames, image) => {
                if (this.isDanglingImage(image)) {
                    return dockerImageNames;
                }
                const dockerImageNamesForImage = image.RepoTags.map((imageRepoTag) => docker_image_name_1.DockerImageName.fromString(imageRepoTag));
                return [...dockerImageNames, ...dockerImageNamesForImage];
            }, []);
        });
    }
    listContainers() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.dockerode.listContainers();
        });
    }
    getContainer(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return new container_1.DockerodeContainer(yield this.dockerode.getContainer(id));
        });
    }
    getHost() {
        return this.host;
    }
    getSessionId() {
        return this.sessionId;
    }
    getSocketPath() {
        return this.dockerode.modem.socketPath;
    }
    isDanglingImage(image) {
        return image.RepoTags === null;
    }
    createLabels(dockerImageName) {
        if (dockerImageName && dockerImageName.isReaper()) {
            return {};
        }
        return { "org.testcontainers.session-id": this.sessionId };
    }
    getEnv(env) {
        return Object.entries(env).reduce((dockerodeEnvironment, [key, value]) => {
            return [...dockerodeEnvironment, `${key}=${value}`];
        }, []);
    }
    getHealthCheck(healthCheck) {
        if (healthCheck === undefined) {
            return undefined;
        }
        return {
            Test: ["CMD-SHELL", healthCheck.test],
            Interval: healthCheck.interval ? this.toNanos(healthCheck.interval) : 0,
            Timeout: healthCheck.timeout ? this.toNanos(healthCheck.timeout) : 0,
            Retries: healthCheck.retries || 0,
            StartPeriod: healthCheck.startPeriod ? this.toNanos(healthCheck.startPeriod) : 0,
        };
    }
    toNanos(duration) {
        return duration * 1e6;
    }
    getExposedPorts(boundPorts) {
        const dockerodeExposedPorts = {};
        for (const [internalPort] of boundPorts.iterator()) {
            dockerodeExposedPorts[internalPort.toString()] = {};
        }
        return dockerodeExposedPorts;
    }
    getExtraHosts(extraHosts) {
        return extraHosts.map((extraHost) => `${extraHost.host}:${extraHost.ipAddress}`);
    }
    getPortBindings(boundPorts) {
        const dockerodePortBindings = {};
        for (const [internalPort, hostPort] of boundPorts.iterator()) {
            dockerodePortBindings[internalPort.toString()] = [{ HostPort: hostPort.toString() }];
        }
        return dockerodePortBindings;
    }
    getBindMounts(bindMounts) {
        return bindMounts.map(({ source, target, bindMode }) => `${source}:${target}:${bindMode}`);
    }
    getLogConfig(useDefaultLogDriver) {
        if (!useDefaultLogDriver) {
            return undefined;
        }
        return {
            Type: "json-file",
            Config: {},
        };
    }
}
exports.DockerodeClient = DockerodeClient;
