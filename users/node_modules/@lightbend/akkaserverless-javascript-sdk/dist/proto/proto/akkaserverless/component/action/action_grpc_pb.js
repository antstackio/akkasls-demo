// GENERATED CODE -- DO NOT EDIT!

// Original file comments:
// Copyright 2021 Lightbend Inc.
//
// gRPC interface for Akka Serverless Actions.
//
'use strict';
var grpc = require('@grpc/grpc-js');
var akkaserverless_component_action_action_pb = require('../../../akkaserverless/component/action/action_pb.js');
var akkaserverless_component_component_pb = require('../../../akkaserverless/component/component_pb.js');
var google_protobuf_any_pb = require('google-protobuf/google/protobuf/any_pb.js');

function serialize_akkaserverless_component_action_ActionCommand(arg) {
  if (!(arg instanceof akkaserverless_component_action_action_pb.ActionCommand)) {
    throw new Error('Expected argument of type akkaserverless.component.action.ActionCommand');
  }
  return Buffer.from(arg.serializeBinary());
}

function deserialize_akkaserverless_component_action_ActionCommand(buffer_arg) {
  return akkaserverless_component_action_action_pb.ActionCommand.deserializeBinary(new Uint8Array(buffer_arg));
}

function serialize_akkaserverless_component_action_ActionResponse(arg) {
  if (!(arg instanceof akkaserverless_component_action_action_pb.ActionResponse)) {
    throw new Error('Expected argument of type akkaserverless.component.action.ActionResponse');
  }
  return Buffer.from(arg.serializeBinary());
}

function deserialize_akkaserverless_component_action_ActionResponse(buffer_arg) {
  return akkaserverless_component_action_action_pb.ActionResponse.deserializeBinary(new Uint8Array(buffer_arg));
}


// Service that the SDK (in the user function) implements to make actions
// available to the proxy
var ActionsService = exports.ActionsService = {
  // Handle a unary command.
//
// The input command will contain the service name, command name, request
// metadata and the command payload. The reply may contain a direct reply, a
// forward or a failure, and it may contain many side effects.
handleUnary: {
    path: '/akkaserverless.component.action.Actions/HandleUnary',
    requestStream: false,
    responseStream: false,
    requestType: akkaserverless_component_action_action_pb.ActionCommand,
    responseType: akkaserverless_component_action_action_pb.ActionResponse,
    requestSerialize: serialize_akkaserverless_component_action_ActionCommand,
    requestDeserialize: deserialize_akkaserverless_component_action_ActionCommand,
    responseSerialize: serialize_akkaserverless_component_action_ActionResponse,
    responseDeserialize: deserialize_akkaserverless_component_action_ActionResponse,
  },
  // Handle a streamed in command.
//
// The first message in will contain the request metadata, including the
// service name and command name. It will not have an associated payload set.
// This will be followed by zero to many messages in with a payload, but no
// service name or command name set.
//
// If the underlying transport supports per stream metadata, rather than per
// message metadata, then that metadata will only be included in the metadata
// of the first message. In contrast, if the underlying transport supports per
// message metadata, there will be no metadata on the first message, the
// metadata will instead be found on each subsequent message.
//
// The semantics of stream closure in this protocol map 1:1 with the semantics
// of gRPC stream closure, that is, when the client closes the stream, the
// stream is considered half closed, and the server should eventually, but not
// necessarily immediately, send a response message with a status code and
// trailers.
//
// If however the server sends a response message before the client closes the
// stream, the stream is completely closed, and the client should handle this
// and stop sending more messages.
//
// Either the client or the server may cancel the stream at any time,
// cancellation is indicated through an HTTP2 stream RST message.
handleStreamedIn: {
    path: '/akkaserverless.component.action.Actions/HandleStreamedIn',
    requestStream: true,
    responseStream: false,
    requestType: akkaserverless_component_action_action_pb.ActionCommand,
    responseType: akkaserverless_component_action_action_pb.ActionResponse,
    requestSerialize: serialize_akkaserverless_component_action_ActionCommand,
    requestDeserialize: deserialize_akkaserverless_component_action_ActionCommand,
    responseSerialize: serialize_akkaserverless_component_action_ActionResponse,
    responseDeserialize: deserialize_akkaserverless_component_action_ActionResponse,
  },
  // Handle a streamed out command.
//
// The input command will contain the service name, command name, request
// metadata and the command payload. Zero or more replies may be sent, each
// containing either a direct reply, a forward or a failure, and each may
// contain many side effects. The stream to the client will be closed when the
// this stream is closed, with the same status as this stream is closed with.
//
// Either the client or the server may cancel the stream at any time,
// cancellation is indicated through an HTTP2 stream RST message.
handleStreamedOut: {
    path: '/akkaserverless.component.action.Actions/HandleStreamedOut',
    requestStream: false,
    responseStream: true,
    requestType: akkaserverless_component_action_action_pb.ActionCommand,
    responseType: akkaserverless_component_action_action_pb.ActionResponse,
    requestSerialize: serialize_akkaserverless_component_action_ActionCommand,
    requestDeserialize: deserialize_akkaserverless_component_action_ActionCommand,
    responseSerialize: serialize_akkaserverless_component_action_ActionResponse,
    responseDeserialize: deserialize_akkaserverless_component_action_ActionResponse,
  },
  // Handle a full duplex streamed command.
//
// The first message in will contain the request metadata, including the
// service name and command name. It will not have an associated payload set.
// This will be followed by zero to many messages in with a payload, but no
// service name or command name set.
//
// Zero or more replies may be sent, each containing either a direct reply, a
// forward or a failure, and each may contain many side effects.
//
// If the underlying transport supports per stream metadata, rather than per
// message metadata, then that metadata will only be included in the metadata
// of the first message. In contrast, if the underlying transport supports per
// message metadata, there will be no metadata on the first message, the
// metadata will instead be found on each subsequent message.
//
// The semantics of stream closure in this protocol map 1:1 with the semantics
// of gRPC stream closure, that is, when the client closes the stream, the
// stream is considered half closed, and the server should eventually, but not
// necessarily immediately, close the stream with a status code and trailers.
//
// If however the server closes the stream with a status code and trailers,
// the stream is immediately considered completely closed, and no further
// messages sent by the client will be handled by the server.
//
// Either the client or the server may cancel the stream at any time,
// cancellation is indicated through an HTTP2 stream RST message.
handleStreamed: {
    path: '/akkaserverless.component.action.Actions/HandleStreamed',
    requestStream: true,
    responseStream: true,
    requestType: akkaserverless_component_action_action_pb.ActionCommand,
    responseType: akkaserverless_component_action_action_pb.ActionResponse,
    requestSerialize: serialize_akkaserverless_component_action_ActionCommand,
    requestDeserialize: deserialize_akkaserverless_component_action_ActionCommand,
    responseSerialize: serialize_akkaserverless_component_action_ActionResponse,
    responseDeserialize: deserialize_akkaserverless_component_action_ActionResponse,
  },
};

exports.ActionsClient = grpc.makeGenericClientConstructor(ActionsService);
