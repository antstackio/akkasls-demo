// GENERATED CODE -- DO NOT EDIT!
// Original file comments:
// Copyright 2021 Lightbend Inc.
//
// gRPC interface for Akka Serverless Actions.
//
'use strict';
var grpc = require('@grpc/grpc-js');
var akkaserverless_component_action_action_pb = require('../../../akkaserverless/component/action/action_pb.js');
var akkaserverless_component_component_pb = require('../../../akkaserverless/component/component_pb.js');
var google_protobuf_any_pb = require('google-protobuf/google/protobuf/any_pb.js');
function serialize_akkaserverless_component_action_ActionCommand(arg) {
    if (!(arg instanceof akkaserverless_component_action_action_pb.ActionCommand)) {
        throw new Error('Expected argument of type akkaserverless.component.action.ActionCommand');
    }
    return Buffer.from(arg.serializeBinary());
}
function deserialize_akkaserverless_component_action_ActionCommand(buffer_arg) {
    return akkaserverless_component_action_action_pb.ActionCommand.deserializeBinary(new Uint8Array(buffer_arg));
}
function serialize_akkaserverless_component_action_ActionResponse(arg) {
    if (!(arg instanceof akkaserverless_component_action_action_pb.ActionResponse)) {
        throw new Error('Expected argument of type akkaserverless.component.action.ActionResponse');
    }
    return Buffer.from(arg.serializeBinary());
}
function deserialize_akkaserverless_component_action_ActionResponse(buffer_arg) {
    return akkaserverless_component_action_action_pb.ActionResponse.deserializeBinary(new Uint8Array(buffer_arg));
}
// Service that the SDK (in the user function) implements to make actions
// available to the proxy
var ActionsService = exports.ActionsService = {
    // Handle a unary command.
    //
    // The input command will contain the service name, command name, request
    // metadata and the command payload. The reply may contain a direct reply, a
    // forward or a failure, and it may contain many side effects.
    handleUnary: {
        path: '/akkaserverless.component.action.Actions/HandleUnary',
        requestStream: false,
        responseStream: false,
        requestType: akkaserverless_component_action_action_pb.ActionCommand,
        responseType: akkaserverless_component_action_action_pb.ActionResponse,
        requestSerialize: serialize_akkaserverless_component_action_ActionCommand,
        requestDeserialize: deserialize_akkaserverless_component_action_ActionCommand,
        responseSerialize: serialize_akkaserverless_component_action_ActionResponse,
        responseDeserialize: deserialize_akkaserverless_component_action_ActionResponse,
    },
    // Handle a streamed in command.
    //
    // The first message in will contain the request metadata, including the
    // service name and command name. It will not have an associated payload set.
    // This will be followed by zero to many messages in with a payload, but no
    // service name or command name set.
    //
    // If the underlying transport supports per stream metadata, rather than per
    // message metadata, then that metadata will only be included in the metadata
    // of the first message. In contrast, if the underlying transport supports per
    // message metadata, there will be no metadata on the first message, the
    // metadata will instead be found on each subsequent message.
    //
    // The semantics of stream closure in this protocol map 1:1 with the semantics
    // of gRPC stream closure, that is, when the client closes the stream, the
    // stream is considered half closed, and the server should eventually, but not
    // necessarily immediately, send a response message with a status code and
    // trailers.
    //
    // If however the server sends a response message before the client closes the
    // stream, the stream is completely closed, and the client should handle this
    // and stop sending more messages.
    //
    // Either the client or the server may cancel the stream at any time,
    // cancellation is indicated through an HTTP2 stream RST message.
    handleStreamedIn: {
        path: '/akkaserverless.component.action.Actions/HandleStreamedIn',
        requestStream: true,
        responseStream: false,
        requestType: akkaserverless_component_action_action_pb.ActionCommand,
        responseType: akkaserverless_component_action_action_pb.ActionResponse,
        requestSerialize: serialize_akkaserverless_component_action_ActionCommand,
        requestDeserialize: deserialize_akkaserverless_component_action_ActionCommand,
        responseSerialize: serialize_akkaserverless_component_action_ActionResponse,
        responseDeserialize: deserialize_akkaserverless_component_action_ActionResponse,
    },
    // Handle a streamed out command.
    //
    // The input command will contain the service name, command name, request
    // metadata and the command payload. Zero or more replies may be sent, each
    // containing either a direct reply, a forward or a failure, and each may
    // contain many side effects. The stream to the client will be closed when the
    // this stream is closed, with the same status as this stream is closed with.
    //
    // Either the client or the server may cancel the stream at any time,
    // cancellation is indicated through an HTTP2 stream RST message.
    handleStreamedOut: {
        path: '/akkaserverless.component.action.Actions/HandleStreamedOut',
        requestStream: false,
        responseStream: true,
        requestType: akkaserverless_component_action_action_pb.ActionCommand,
        responseType: akkaserverless_component_action_action_pb.ActionResponse,
        requestSerialize: serialize_akkaserverless_component_action_ActionCommand,
        requestDeserialize: deserialize_akkaserverless_component_action_ActionCommand,
        responseSerialize: serialize_akkaserverless_component_action_ActionResponse,
        responseDeserialize: deserialize_akkaserverless_component_action_ActionResponse,
    },
    // Handle a full duplex streamed command.
    //
    // The first message in will contain the request metadata, including the
    // service name and command name. It will not have an associated payload set.
    // This will be followed by zero to many messages in with a payload, but no
    // service name or command name set.
    //
    // Zero or more replies may be sent, each containing either a direct reply, a
    // forward or a failure, and each may contain many side effects.
    //
    // If the underlying transport supports per stream metadata, rather than per
    // message metadata, then that metadata will only be included in the metadata
    // of the first message. In contrast, if the underlying transport supports per
    // message metadata, there will be no metadata on the first message, the
    // metadata will instead be found on each subsequent message.
    //
    // The semantics of stream closure in this protocol map 1:1 with the semantics
    // of gRPC stream closure, that is, when the client closes the stream, the
    // stream is considered half closed, and the server should eventually, but not
    // necessarily immediately, close the stream with a status code and trailers.
    //
    // If however the server closes the stream with a status code and trailers,
    // the stream is immediately considered completely closed, and no further
    // messages sent by the client will be handled by the server.
    //
    // Either the client or the server may cancel the stream at any time,
    // cancellation is indicated through an HTTP2 stream RST message.
    handleStreamed: {
        path: '/akkaserverless.component.action.Actions/HandleStreamed',
        requestStream: true,
        responseStream: true,
        requestType: akkaserverless_component_action_action_pb.ActionCommand,
        responseType: akkaserverless_component_action_action_pb.ActionResponse,
        requestSerialize: serialize_akkaserverless_component_action_ActionCommand,
        requestDeserialize: deserialize_akkaserverless_component_action_ActionCommand,
        responseSerialize: serialize_akkaserverless_component_action_ActionResponse,
        responseDeserialize: deserialize_akkaserverless_component_action_ActionResponse,
    },
};
exports.ActionsClient = grpc.makeGenericClientConstructor(ActionsService);
//# sourceMappingURL=action_grpc_pb.js.map