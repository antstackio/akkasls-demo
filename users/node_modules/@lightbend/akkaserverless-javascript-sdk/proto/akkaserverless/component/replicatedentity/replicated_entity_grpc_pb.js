// GENERATED CODE -- DO NOT EDIT!

// Original file comments:
// Copyright 2021 Lightbend Inc.
//
// gRPC interface for Replicated Entity user functions.
//
'use strict';
var grpc = require('@grpc/grpc-js');
var akkaserverless_component_replicatedentity_replicated_entity_pb = require('@lightbend/akkaserverless-javascript-sdk/proto/akkaserverless/component/replicatedentity/replicated_entity_pb');
var akkaserverless_component_component_pb = require('@lightbend/akkaserverless-javascript-sdk/proto/akkaserverless/component/component_pb');
var akkaserverless_component_entity_entity_pb = require('@lightbend/akkaserverless-javascript-sdk/proto/akkaserverless/component/entity/entity_pb');
var google_protobuf_any_pb = require('google-protobuf/google/protobuf/any_pb.js');

function serialize_akkaserverless_component_replicatedentity_ReplicatedEntityStreamIn(arg) {
  if (!(arg instanceof akkaserverless_component_replicatedentity_replicated_entity_pb.ReplicatedEntityStreamIn)) {
    throw new Error('Expected argument of type akkaserverless.component.replicatedentity.ReplicatedEntityStreamIn');
  }
  return Buffer.from(arg.serializeBinary());
}

function deserialize_akkaserverless_component_replicatedentity_ReplicatedEntityStreamIn(buffer_arg) {
  return akkaserverless_component_replicatedentity_replicated_entity_pb.ReplicatedEntityStreamIn.deserializeBinary(new Uint8Array(buffer_arg));
}

function serialize_akkaserverless_component_replicatedentity_ReplicatedEntityStreamOut(arg) {
  if (!(arg instanceof akkaserverless_component_replicatedentity_replicated_entity_pb.ReplicatedEntityStreamOut)) {
    throw new Error('Expected argument of type akkaserverless.component.replicatedentity.ReplicatedEntityStreamOut');
  }
  return Buffer.from(arg.serializeBinary());
}

function deserialize_akkaserverless_component_replicatedentity_ReplicatedEntityStreamOut(buffer_arg) {
  return akkaserverless_component_replicatedentity_replicated_entity_pb.ReplicatedEntityStreamOut.deserializeBinary(new Uint8Array(buffer_arg));
}


// Replicated Entities Protocol
//
// Note that while this protocol provides support for replicated entities, the data
// types sent across the protocol are not replicated entities themselves. It is the
// responsibility of the Akka Serverless proxy to implement the replicated entities,
// merge functions, vector clocks etc, not the user function. The user function
// need only hold the current value in memory, and this protocol sends deltas to the
// user function to update its in memory value as necessary. These deltas have no
// way of dealing with conflicts, hence it important that the Akka Serverless proxy
// always know what the state of the user functions in memory value is before
// sending a delta. If the Akka Serverless proxy is not sure what the value is, eg
// because it has just sent an operation to the user function may have updated its
// value as a result, the proxy should wait until it gets the result of the operation
// back, to ensure its in memory value is in sync with the user function so that
// it can calculate deltas that won't conflict.
//
// The user function is expected to update its value both as the result of
// receiving deltas from the proxy, as well as when it sends deltas. It must not
// update its value in any other circumstance, updating the value in response to
// any other stimuli risks the value becoming out of sync with the Akka
// Serverless proxy. The user function will not be sent back deltas as a result
// of its own changes.
//
// An invocation of handle is made for each entity being handled. It may be kept
// alive and used to handle multiple commands, and may subsequently be
// terminated if that entity becomes idle, or if the entity is deleted. Shutdown
// is typically done for efficiency reasons, unless the entity is explicitly
// deleted, a terminated handle stream does not mean the proxy has stopped
// tracking the state of the entity in its memory.
//
// Special care must be taken when working with maps and sets. The keys/values
// are google.protobuf.Any, which encodes the value as binary protobuf, however,
// serialized protobufs are not stable, two semantically equal objects could
// encode to different bytes. It is the responsibility of the user function to
// ensure that stable encodings are used.
var ReplicatedEntitiesService = exports.ReplicatedEntitiesService = {
  // After invoking handle, the first message sent will always be a
// ReplicatedEntityInit message, containing the entity ID, and, if it exists or
// is available, a delta for the initial state of the entity. After that, one or
// more commands may be sent, as well as deltas as they arrive.
//
// The user function must respond with one reply per command in. They do not
// necessarily have to be sent in the same order that the commands were sent,
// the command ID is used to correlate commands to replies.
handle: {
    path: '/akkaserverless.component.replicatedentity.ReplicatedEntities/Handle',
    requestStream: true,
    responseStream: true,
    requestType: akkaserverless_component_replicatedentity_replicated_entity_pb.ReplicatedEntityStreamIn,
    responseType: akkaserverless_component_replicatedentity_replicated_entity_pb.ReplicatedEntityStreamOut,
    requestSerialize: serialize_akkaserverless_component_replicatedentity_ReplicatedEntityStreamIn,
    requestDeserialize: deserialize_akkaserverless_component_replicatedentity_ReplicatedEntityStreamIn,
    responseSerialize: serialize_akkaserverless_component_replicatedentity_ReplicatedEntityStreamOut,
    responseDeserialize: deserialize_akkaserverless_component_replicatedentity_ReplicatedEntityStreamOut,
  },
};

exports.ReplicatedEntitiesClient = grpc.makeGenericClientConstructor(ReplicatedEntitiesService);
