import Dockerode from "dockerode";
import { BoundPorts } from "./bound-ports";
import { Container, Id } from "./container";
import { Host } from "./docker-client-instance";
import { DockerImageName } from "./docker-image-name";
export declare type Command = string;
export declare type ContainerName = string;
export declare type NetworkMode = string;
export declare type ExitCode = number;
export declare type EnvKey = string;
export declare type EnvValue = string;
export declare type Env = {
    [key in EnvKey]: EnvValue;
};
export declare type Dir = string;
export declare type TmpFs = {
    [dir in Dir]: Dir;
};
export declare type HealthCheck = {
    test: string;
    interval?: number;
    timeout?: number;
    retries?: number;
    startPeriod?: number;
};
export declare type BuildContext = string;
export declare type BuildArgs = {
    [key in EnvKey]: EnvValue;
};
export declare type StreamOutput = string;
export declare type ExecResult = {
    output: StreamOutput;
    exitCode: ExitCode;
};
export declare type BindMode = "rw" | "ro";
export declare type BindMount = {
    source: Dir;
    target: Dir;
    bindMode: BindMode;
};
export declare type ExtraHost = {
    host: Host;
    ipAddress: string;
};
export declare type AuthConfig = {
    username: string;
    password: string;
    registryAddress: string;
    email?: string;
};
declare type CreateOptions = {
    dockerImageName: DockerImageName;
    env: Env;
    cmd: Command[];
    bindMounts: BindMount[];
    tmpFs: TmpFs;
    boundPorts: BoundPorts;
    name?: ContainerName;
    networkMode?: NetworkMode;
    healthCheck?: HealthCheck;
    useDefaultLogDriver: boolean;
    privilegedMode: boolean;
    autoRemove: boolean;
    extraHosts: ExtraHost[];
};
export declare type CreateNetworkOptions = {
    name: string;
    driver: "bridge" | "overlay" | string;
    checkDuplicate: boolean;
    internal: boolean;
    attachable: boolean;
    ingress: boolean;
    enableIPv6: boolean;
    labels?: {
        [key: string]: string;
    };
    options?: {
        [key: string]: string;
    };
};
export interface DockerClient {
    pull(dockerImageName: DockerImageName, authConfig?: AuthConfig): Promise<void>;
    create(options: CreateOptions): Promise<Container>;
    createNetwork(options: CreateNetworkOptions): Promise<string>;
    removeNetwork(id: string): Promise<void>;
    connectToNetwork(containerId: string, networkId: string): Promise<void>;
    start(container: Container): Promise<void>;
    exec(container: Container, command: Command[]): Promise<ExecResult>;
    buildImage(dockerImageName: DockerImageName, context: BuildContext, dockerfileName: string, buildArgs: BuildArgs): Promise<void>;
    fetchDockerImageNames(): Promise<DockerImageName[]>;
    listContainers(): Promise<Dockerode.ContainerInfo[]>;
    getContainer(id: Id): Promise<Container>;
    getHost(): Host;
    getSessionId(): Id;
    getSocketPath(): string;
}
export declare class DockerodeClient implements DockerClient {
    private readonly host;
    private readonly dockerode;
    private readonly sessionId;
    constructor(host: Host, dockerode: Dockerode, sessionId: Id);
    pull(dockerImageName: DockerImageName, authConfig?: AuthConfig): Promise<void>;
    create(options: CreateOptions): Promise<Container>;
    connectToNetwork(containerId: string, networkId: string): Promise<void>;
    createNetwork(options: CreateNetworkOptions): Promise<string>;
    removeNetwork(id: string): Promise<void>;
    start(container: Container): Promise<void>;
    exec(container: Container, command: Command[]): Promise<ExecResult>;
    buildImage(dockerImageName: DockerImageName, context: BuildContext, dockerfileName: string, buildArgs: BuildArgs): Promise<void>;
    fetchDockerImageNames(): Promise<DockerImageName[]>;
    listContainers(): Promise<Dockerode.ContainerInfo[]>;
    getContainer(id: Id): Promise<Container>;
    getHost(): Host;
    getSessionId(): Id;
    getSocketPath(): string;
    private isDanglingImage;
    private createLabels;
    private getEnv;
    private getHealthCheck;
    private toNanos;
    private getExposedPorts;
    private getExtraHosts;
    private getPortBindings;
    private getBindMounts;
    private getLogConfig;
}
export {};
