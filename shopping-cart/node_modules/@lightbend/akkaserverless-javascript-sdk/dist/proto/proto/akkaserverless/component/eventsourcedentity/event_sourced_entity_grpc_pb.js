// GENERATED CODE -- DO NOT EDIT!

// Original file comments:
// Copyright 2021 Lightbend Inc.
//
// gRPC interface for Event Sourced Entity user functions.
//
'use strict';
var grpc = require('@grpc/grpc-js');
var akkaserverless_component_eventsourcedentity_event_sourced_entity_pb = require('../../../akkaserverless/component/eventsourcedentity/event_sourced_entity_pb.js');
var akkaserverless_component_component_pb = require('../../../akkaserverless/component/component_pb.js');
var akkaserverless_component_entity_entity_pb = require('../../../akkaserverless/component/entity/entity_pb.js');
var google_protobuf_any_pb = require('google-protobuf/google/protobuf/any_pb.js');

function serialize_akkaserverless_component_eventsourcedentity_EventSourcedStreamIn(arg) {
  if (!(arg instanceof akkaserverless_component_eventsourcedentity_event_sourced_entity_pb.EventSourcedStreamIn)) {
    throw new Error('Expected argument of type akkaserverless.component.eventsourcedentity.EventSourcedStreamIn');
  }
  return Buffer.from(arg.serializeBinary());
}

function deserialize_akkaserverless_component_eventsourcedentity_EventSourcedStreamIn(buffer_arg) {
  return akkaserverless_component_eventsourcedentity_event_sourced_entity_pb.EventSourcedStreamIn.deserializeBinary(new Uint8Array(buffer_arg));
}

function serialize_akkaserverless_component_eventsourcedentity_EventSourcedStreamOut(arg) {
  if (!(arg instanceof akkaserverless_component_eventsourcedentity_event_sourced_entity_pb.EventSourcedStreamOut)) {
    throw new Error('Expected argument of type akkaserverless.component.eventsourcedentity.EventSourcedStreamOut');
  }
  return Buffer.from(arg.serializeBinary());
}

function deserialize_akkaserverless_component_eventsourcedentity_EventSourcedStreamOut(buffer_arg) {
  return akkaserverless_component_eventsourcedentity_event_sourced_entity_pb.EventSourcedStreamOut.deserializeBinary(new Uint8Array(buffer_arg));
}


// Service that the SDK (in the user function) implements to make event-sourced
// entities available to the proxy
var EventSourcedEntitiesService = exports.EventSourcedEntitiesService = {
  // The stream. One stream will be established per active entity. Once
// established, the first message sent will be Init, which contains the entity
// ID, and, if the entity has previously persisted a snapshot, it will contain
// that snapshot. It will then send zero to many event messages, one for each
// event previously persisted. The entity is expected to apply these to its
// state in a deterministic fashion. Once all the events are sent, one to many
// commands are sent, with new commands being sent as new requests for the
// entity come in. The entity is expected to reply to each command with
// exactly one reply message. The entity should reply in order, and any events
// that the entity requests to be persisted the entity should handle itself,
// applying them to its own state, as if they had arrived as events when the
// event stream was being replayed on load.
handle: {
    path: '/akkaserverless.component.eventsourcedentity.EventSourcedEntities/Handle',
    requestStream: true,
    responseStream: true,
    requestType: akkaserverless_component_eventsourcedentity_event_sourced_entity_pb.EventSourcedStreamIn,
    responseType: akkaserverless_component_eventsourcedentity_event_sourced_entity_pb.EventSourcedStreamOut,
    requestSerialize: serialize_akkaserverless_component_eventsourcedentity_EventSourcedStreamIn,
    requestDeserialize: deserialize_akkaserverless_component_eventsourcedentity_EventSourcedStreamIn,
    responseSerialize: serialize_akkaserverless_component_eventsourcedentity_EventSourcedStreamOut,
    responseDeserialize: deserialize_akkaserverless_component_eventsourcedentity_EventSourcedStreamOut,
  },
};

exports.EventSourcedEntitiesClient = grpc.makeGenericClientConstructor(EventSourcedEntitiesService);
