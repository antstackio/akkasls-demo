"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReaperInstance = void 0;
const net_1 = require("net");
const logger_1 = require("./logger");
const generic_container_1 = require("./generic-container");
const wait_1 = require("./wait");
class RealReaper {
    constructor(sessionId, container, socket) {
        this.sessionId = sessionId;
        this.container = container;
        this.socket = socket;
    }
    addProject(projectName) {
        this.socket.write(`label=com.docker.compose.project=${projectName}\r\n`);
    }
}
class DisabledReaper {
    addProject() {
        // noop
    }
}
class ReaperInstance {
    static getInstance(dockerClient) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.instance) {
                if (this.isEnabled()) {
                    this.instance = this.createRealInstance(dockerClient);
                }
                else {
                    this.instance = this.createDisabledInstance(dockerClient);
                }
            }
            return this.instance;
        });
    }
    static getImage() {
        return process.env.RYUK_CONTAINER_IMAGE === undefined ? this.DEFAULT_IMAGE : process.env.RYUK_CONTAINER_IMAGE;
    }
    static isEnabled() {
        return process.env.TESTCONTAINERS_RYUK_DISABLED !== "true";
    }
    static createDisabledInstance(dockerClient) {
        const sessionId = dockerClient.getSessionId();
        logger_1.log.debug(`Not creating new Reaper for session: ${sessionId}`);
        return Promise.resolve(new DisabledReaper());
    }
    static createRealInstance(dockerClient) {
        return __awaiter(this, void 0, void 0, function* () {
            const sessionId = dockerClient.getSessionId();
            logger_1.log.debug(`Creating new Reaper for session: ${sessionId}`);
            const container = yield new generic_container_1.GenericContainer(this.getImage())
                .withName(`testcontainers-ryuk-${sessionId}`)
                .withExposedPorts(8080)
                .withWaitStrategy(wait_1.Wait.forLogMessage("Started!"))
                .withBindMount("/var/run/docker.sock", "/var/run/docker.sock")
                .withDaemonMode()
                .withPrivilegedMode()
                .start();
            const host = dockerClient.getHost();
            const port = container.getMappedPort(8080);
            logger_1.log.debug(`Connecting to Reaper on ${host}:${port}`);
            const socket = new net_1.Socket();
            socket.unref();
            socket.on("close", () => {
                logger_1.log.warn("Connection to Reaper closed");
            });
            return yield new Promise((resolve) => {
                socket.connect(port, host, () => {
                    logger_1.log.debug(`Connected to Reaper`);
                    socket.write(`label=org.testcontainers.session-id=${sessionId}\r\n`);
                    const reaper = new RealReaper(sessionId, container, socket);
                    resolve(reaper);
                });
            });
        });
    }
}
exports.ReaperInstance = ReaperInstance;
ReaperInstance.DEFAULT_IMAGE = "testcontainers/ryuk:0.3.0";
